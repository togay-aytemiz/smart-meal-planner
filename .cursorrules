# Smart Meal Planner - Cursor Rules

## Response Format

Her yanıt şu formatta olmalı:

```
### Yapılanlar
- [Türkçe bullet 1]
- [Türkçe bullet 2]
- [Türkçe bullet 3 - opsiyonel]

### Önerilen Sonraki Adımlar (opsiyonel)
- [Öneri 1]
- [Öneri 2]

### Commit
`[English commit message - imperative mood, max 72 chars]`
```

**Örnek:**

```
### Yapılanlar
- Onboarding ekranları için temel layout oluşturuldu
- Welcome screen UI tamamlandı
- Navigation flow ayarlandı

### Önerilen Sonraki Adımlar
- Dietary requirements ekranına geçilebilir
- Animasyonlar eklenebilir

### Commit
`feat(onboarding): add welcome screen with value proposition`
```

---

## Tech Stack Rules

### ✅ Use

| Category         | Technology                                 |
| ---------------- | ------------------------------------------ |
| Framework        | React Native + Expo                        |
| Navigation       | Expo Router                                |
| State Management | Context API + useReducer                   |
| Local Storage    | AsyncStorage                               |
| Styling          | StyleSheet.create()                        |
| Backend          | Firebase (Auth, Firestore, Storage)        |
| AI Integration   | OpenAI / Claude API via Firebase Functions |
| Icons            | expo/vector-icons veya custom SVG          |

### ❌ Don't Use

- ~~Zustand~~ → Context API kullan
- ~~NativeWind / Tailwind~~ → StyleSheet kullan
- ~~Redux~~ → Context + useReducer yeterli
- ~~Styled Components~~ → Native StyleSheet

---

## Design Philosophy

### Core Principles

1. **Minimal** - Her ekranda sadece gerekli olan var
2. **Aesthetic** - Premium hissi veren, göz yormayan tasarım
3. **Cool** - Modern, trendy ama zamansız
4. **Intuitive** - Açıklama gerektirmeyen UX

### Minimal Design Rules

1. **One primary action per screen** - Her ekranda tek ana CTA
2. **Progressive disclosure** - Bilgiyi gerektikçe göster, hepsini birden değil
3. **Content-first** - Decorative elements minimum, content maksimum
4. **Negative space** - Boşluklar içeriği vurgular, çok doldurma
5. **Visual hierarchy** - Font size, weight, color ile hierarchy oluştur

### Aesthetic Guidelines

1. **Consistent spacing** - 4px base unit system kullan
2. **Harmonious colors** - Palet dışı renk kullanma
3. **Typography scale** - Sadece tanımlı typography değerleri kullan
4. **Subtle animations** - Smooth, purposeful, never distracting
5. **Quality over quantity** - Az ama iyi, çok ama kötü değil

### Cool & Modern Practices

1. **Micro-interactions** - Small delightful moments (haptic feedback, subtle animations)
2. **Smooth transitions** - Page transitions ve state changes
3. **Loading elegance** - Skeleton screens, shimmer effects
4. **Empty states** - Opportunity to delight, not just inform
5. **Error states** - Friendly, helpful, not scary

### Visual Identity

**Renk Paleti:**

- Background: `#FAFAF9` (Warm White)
- Surface: `#FFFFFF`
- Primary: `#2D6A4F` (Forest Green)
- Primary Light: `#40916C`
- Accent: `#E76F51` (Coral)
- Text Primary: `#1F2937`
- Text Secondary: `#6B7280`
- Text Muted: `#9CA3AF`
- Border: `#E5E7EB`
- Success: `#10B981`
- Warning: `#F59E0B`
- Error: `#EF4444`

### Typography

```typescript
export const typography = {
  // Headings
  h1: { fontSize: 32, fontWeight: "700", lineHeight: 40 },
  h2: { fontSize: 24, fontWeight: "600", lineHeight: 32 },
  h3: { fontSize: 20, fontWeight: "600", lineHeight: 28 },

  // Body
  body: { fontSize: 16, fontWeight: "400", lineHeight: 24 },
  bodySmall: { fontSize: 14, fontWeight: "400", lineHeight: 20 },

  // UI
  button: { fontSize: 16, fontWeight: "600", lineHeight: 24 },
  caption: { fontSize: 12, fontWeight: "500", lineHeight: 16 },
  label: { fontSize: 14, fontWeight: "500", lineHeight: 20 },
};
```

### Spacing System (4px base unit)

```typescript
export const spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
};
```

### Border Radius

```typescript
export const radius = {
  sm: 8,
  md: 12,
  lg: 16,
  xl: 24,
  full: 9999,
};
```

### Layout Rules

- **Header Spacing**: Navigasyon barı olan sayfalarda `paddingTop` ekleme. Layout zaten boşluk bırakıyor.
- **Content Padding**: `paddingHorizontal: spacing.lg` standarttır.
- **Top Margin**: Sayfa başlıklarında `marginTop` kullanma, `spacing.sm` veya 0 yeterli.

---

## Component Rules

### General

1. **Her component tek dosyada** - styles aynı dosyanın altında
2. **Props interface'i component üstünde** tanımla
3. **Default export** kullan
4. **Atomic design** - ui/ altında base components

### StyleSheet Pattern

```typescript
// ✅ DOĞRU
import { View, Text, StyleSheet } from "react-native";

export default function MyComponent() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Hello</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: "#FAFAF9",
  },
  title: {
    fontSize: 24,
    fontWeight: "600",
    color: "#1F2937",
  },
});
```

### Component Structure

```
src/
├── app/                  # Expo Router routes
├── components/
│   ├── ui/                # Base components
│   │   ├── Button.tsx
│   │   ├── Card.tsx
│   │   ├── Input.tsx
│   │   └── index.ts
│   ├── onboarding/        # Feature-specific
│   │   ├── WelcomeScreen.tsx
│   │   └── DietaryTags.tsx
│   └── index.ts
├── contexts/
├── hooks/
├── theme/
├── types/
└── utils/
```

---

## Context API Pattern

```typescript
// contexts/MealPlanContext.tsx
import { createContext, useContext, useReducer, ReactNode } from "react";

interface State {
  // state type
}

type Action = { type: "SET_MEALS"; payload: Meal[] } | { type: "CLEAR" };

const MealPlanContext = createContext<{
  state: State;
  dispatch: React.Dispatch<Action>;
} | null>(null);

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "SET_MEALS":
      return { ...state, meals: action.payload };
    default:
      return state;
  }
}

export function MealPlanProvider({ children }: { children: ReactNode }) {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <MealPlanContext.Provider value={{ state, dispatch }}>
      {children}
    </MealPlanContext.Provider>
  );
}

export function useMealPlan() {
  const context = useContext(MealPlanContext);
  if (!context) throw new Error("useMealPlan must be used within provider");
  return context;
}
```

---

## UI/UX Rules

### Do's ✅

- **Çok boşluk bırak** - Elemanlar arasında nefes alsın
- **Subtle shadows** - shadowOpacity: 0.05-0.08
- **Soft corners** - borderRadius: 12-16
- **Haptic feedback** - Önemli aksiyonlarda
- **Smooth transitions** - 200-300ms animasyonlar
- **Large touch targets** - Min 44x44 px
- **Clear hierarchy** - Bir ana CTA per ekran

### Don'ts ❌

- Harsh renkler (pure black #000, pure white #FFF)
- Çok fazla bilgi tek ekranda
- Tiny touch targets
- Jarring transitions
- Multiple competing CTAs
- Placeholder images - Her zaman gerçek veya generated
- **Emoji kullanımı** - Welcome ekranında ve genel UI tasarımında emoji yerine profesyonel ikonlar (vector-icons) kullanılmalı
- Cluttered interfaces - Elemanlar arası minimal spacing
- Inconsistent spacing - Random padding/margin değerleri
- Over-animation - Her şeyin animasyonu olması gerekmiyor
- Busy backgrounds - Background pattern/texture minimal olmalı
- Too many font sizes - Typography scale'e uy

### Animation Guidelines

```typescript
const ANIMATION = {
  duration: {
    fast: 150,
    normal: 250,
    slow: 400,
  },
  easing: {
    default: "ease-out",
    spring: { damping: 15, stiffness: 150 },
  },
};
```

---

## File Naming

| Type       | Convention                | Example              |
| ---------- | ------------------------- | -------------------- |
| Components | kebab-case                | `welcome-screen.tsx` |
| Hooks      | kebab-case + use prefix   | `use-onboarding.ts`  |
| Contexts   | kebab-case + context      | `auth-context.tsx`   |
| Utils      | kebab-case                | `format-date.ts`     |
| Types      | kebab-case                | `types/meal.ts`      |
| Constants  | SCREAMING_SNAKE (in file) | `API_URL`            |
| Folders    | kebab-case                | `src/components/ui/` |

---

## Firebase Structure

```
firestore/
├── users/{userId}
│   ├── profile: { name, email, createdAt }
│   ├── preferences: { dietary, goals, cookingLevel }
│   └── members/{memberId}: { name, role, age, prefs }
│
├── mealPlans/{planId}
│   ├── userId, weekStart, weekEnd
│   └── days: { mon: { breakfast, lunch, dinner }, ... }
│
├── recipes/{recipeId}
│   ├── name, ingredients[], instructions[]
│   └── metadata: { prepTime, difficulty, tags[] }
│
└── groceryLists/{listId}
    ├── userId, weekOf
    └── items: [{ name, qty, checked }]
```

---

## Git Commit Convention

```
type(scope): description

Types:
- feat:     Yeni özellik
- fix:      Bug fix
- refactor: Kod değişikliği (davranış aynı)
- style:    Formatting, styling
- docs:     Dokümantasyon
- chore:    Build, config, dependencies
```

**Examples:**

```
feat(onboarding): add dietary requirements screen
fix(calendar): resolve date picker crash on Android
refactor(context): migrate meal state to useReducer
style(button): update primary button hover state
```

---

## Code Quality

1. **TypeScript strict mode** - `"strict": true`
2. **No `any`** - Her zaman proper type
3. **Meaningful variable names** - `isLoading` not `flag`
4. **Early returns** - Nested if'lerden kaçın
5. **Single responsibility** - Bir function bir iş yapar

---

## Error Handling & Robustness

### Error Boundaries Pattern

```typescript
// components/error-boundary.tsx
import React, { Component, ErrorInfo, ReactNode } from "react";
import { View, Text, StyleSheet } from "react-native";

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error: Error | null;
}

export default class ErrorBoundary extends Component<Props, State> {
  state: State = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log to error reporting service (e.g., Sentry)
    console.error("ErrorBoundary caught:", error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return this.props.fallback || <ErrorFallback />;
    }
    return this.props.children;
  }
}
```

### Error Handling Rules

1. **Try-catch blocks** - Tüm async operations için
2. **Error states** - UI'da her zaman error state göster
3. **User-friendly messages** - Teknik hataları kullanıcıya basit dille açıkla
4. **Graceful degradation** - Hata durumunda uygulama crash etmesin
5. **Logging** - Production'da error logging kullan (console.error yerine)

### Async Operation Pattern

```typescript
// ✅ DOĞRU
const [state, setState] = useState<AsyncState<Data>>({
  data: null,
  loading: false,
  error: null,
});

const fetchData = async () => {
  setState((prev) => ({ ...prev, loading: true, error: null }));
  try {
    const data = await api.fetchData();
    setState({ data, loading: false, error: null });
  } catch (error) {
    const message = error instanceof Error ? error.message : "Unknown error";
    setState({ data: null, loading: false, error: message });
  }
};
```

### Network Error Handling

- **Offline detection** - Network durumunu kontrol et
- **Retry mechanism** - Failed requests için exponential backoff
- **Timeout handling** - Request timeout'ları tanımla (max 30s)
- **Cached fallback** - Network hatasında cache'den göster

---

## Loading States

### Loading State Patterns

```typescript
// ✅ DOĞRU - Skeleton/Shimmer kullan
<SkeletonLoader count={3} />

// ❌ YANLIŞ - Sadece spinner
<ActivityIndicator />
```

### Loading Rules

1. **Skeleton screens** - Liste ve card'lar için shimmer effect
2. **Optimistic updates** - Mümkün olduğunda optimistic UI
3. **Progressive loading** - Büyük veriler için pagination/infinite scroll
4. **Loading priorities** - Above-the-fold içerik öncelikli
5. **Subtle indicators** - Küçük işlemler için minimal indicator

---

## Performance Optimization

### React Performance

1. **React.memo** - Expensive components için memoization
2. **useMemo/useCallback** - Heavy computations ve callback'ler için
3. **Lazy loading** - Route-level code splitting
4. **Image optimization** - Expo Image kullan, resize ve cache
5. **FlatList optimization** - `keyExtractor`, `getItemLayout`, `removeClippedSubviews`

### Bundle Size

- **Tree shaking** - Sadece kullanılan import'lar
- **Dynamic imports** - Büyük dependencies için
- **Asset optimization** - Images ve fonts optimize et

### Performance Patterns

```typescript
// ✅ DOĞRU - useMemo for expensive calculations
const filteredData = useMemo(() => data.filter((item) => item.active), [data]);

// ✅ DOĞRU - useCallback for stable references
const handlePress = useCallback(() => {
  onPress(id);
}, [id, onPress]);

// ✅ DOĞRU - FlatList optimization
<FlatList
  data={items}
  keyExtractor={(item) => item.id}
  getItemLayout={(data, index) => ({
    length: ITEM_HEIGHT,
    offset: ITEM_HEIGHT * index,
    index,
  })}
  removeClippedSubviews
  maxToRenderPerBatch={10}
  windowSize={5}
/>;
```

---

## Accessibility (a11y)

### Accessibility Rules

1. **Semantic labels** - `accessibilityLabel` her interactive element için
2. **Touch targets** - Min 44x44px (iOS/Android standard)
3. **Color contrast** - WCAG AA minimum (4.5:1 ratio)
4. **Dynamic Type** - Font scaling'e uyumlu (`allowFontScaling`)
5. **Screen reader support** - VoiceOver ve TalkBack test et

### Accessibility Pattern

```typescript
// ✅ DOĞRU
<TouchableOpacity
  accessible
  accessibilityLabel="Save meal plan"
  accessibilityHint="Saves your current meal plan"
  accessibilityRole="button"
  style={styles.button}
>
  <Text style={styles.buttonText}>Save</Text>
</TouchableOpacity>
```

---

## Type Safety

### Type Patterns

```typescript
// ✅ DOĞRU - Discriminated unions
type AsyncState<T> =
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: T }
  | { status: "error"; error: string };

// ✅ DOĞRU - Branded types for IDs
type UserId = string & { readonly brand: unique symbol };
type MealPlanId = string & { readonly brand: unique symbol };

// ✅ DOĞRU - Type guards
function isMealPlan(data: unknown): data is MealPlan {
  return (
    typeof data === "object" &&
    data !== null &&
    "id" in data &&
    "userId" in data
  );
}
```

### Type Rules

1. **No `any`** - `unknown` kullan, sonra type guard ile narrow et
2. **Strict null checks** - Optional chaining ve nullish coalescing
3. **Discriminated unions** - State machine pattern'ler için
4. **Type guards** - Runtime validation için

---

## Form Validation

### Validation Pattern

```typescript
// utils/validation.ts
type ValidationResult = { isValid: true } | { isValid: false; error: string };

export function validateEmail(email: string): ValidationResult {
  if (!email) {
    return { isValid: false, error: "Email is required" };
  }
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email)) {
    return { isValid: false, error: "Invalid email format" };
  }
  return { isValid: true };
}
```

### Form Rules

1. **Client-side validation** - Immediate feedback
2. **Server-side validation** - Always validate on backend
3. **Debounced validation** - Real-time validation için debounce
4. **Error messages** - Clear, actionable error messages
5. **Validation on blur** - Avoid aggressive validation on every keystroke

---

## Image Handling

### Image Rules

1. **Expo Image** - `expo-image` kullan (optimized)
2. **Placeholders** - Loading ve error states için placeholder
3. **Lazy loading** - Viewport dışındaki images lazy load
4. **Resize optimization** - Appropriate sizes için resize
5. **Caching** - Image cache strategy

### Image Pattern

```typescript
// ✅ DOĞRU
import { Image } from "expo-image";

<Image
  source={{ uri: imageUrl }}
  placeholder={require("../assets/placeholder.png")}
  contentFit="cover"
  transition={200}
  style={styles.image}
/>;
```

---

## Security Best Practices

### Security Rules

1. **No sensitive data in code** - API keys, secrets environment variables'da
2. **Input sanitization** - User input'ları sanitize et
3. **Firebase Security Rules** - Firestore rules yaz
4. **Authentication checks** - Protected routes için auth check
5. **HTTPS only** - Tüm network requests HTTPS

### Environment Variables

```typescript
// ✅ DOĞRU
const API_URL = process.env.EXPO_PUBLIC_API_URL || "";
// ❌ YANLIŞ - Hardcoded secrets
const API_KEY = "sk-1234567890";
```

---

## Empty States & Error States

### Empty State Pattern

```typescript
// ✅ DOĞRU - Minimal, aesthetic empty state
<View style={styles.emptyContainer}>
  <MaterialCommunityIcons
    name="calendar-blank"
    size={64}
    color={colors.textMuted}
  />
  <Text style={styles.emptyTitle}>No meal plans yet</Text>
  <Text style={styles.emptyDescription}>
    Create your first meal plan to get started
  </Text>
  <Button title="Create Plan" onPress={handleCreate} />
</View>
```

### Empty/Error State Rules

1. **Clear messaging** - Ne olduğunu ve ne yapılacağını açıkla
2. **Visual hierarchy** - Icon, title, description, action
3. **Actionable** - Empty state'te action button ekle
4. **Consistent design** - Tüm empty/error states aynı pattern

---

## Platform-Specific Considerations

### iOS vs Android

1. **Safe areas** - `SafeAreaView` veya `useSafeAreaInsets` kullan
2. **Status bar** - Platform'a göre status bar styling
3. **Haptics** - iOS'ta subtle, Android'de daha prominent
4. **Navigation** - Platform conventions'a uy (back button, gestures)
5. **Permissions** - Platform-specific permission handling

### Platform Pattern

```typescript
import { Platform } from "react-native";

const styles = StyleSheet.create({
  container: {
    paddingTop: Platform.select({
      ios: 0,
      android: spacing.md,
    }),
  },
});
```

---

## Testing Considerations

### Testable Code Patterns

1. **Pure functions** - Test edilebilir utility functions
2. **Dependency injection** - Mock'lanabilir dependencies
3. **Separation of concerns** - Business logic UI'dan ayrı
4. **Type safety** - Type errors compile-time'da yakalanır

### Testing Structure

```
src/
├── __tests__/
│   ├── utils/
│   │   └── validation.test.ts
│   └── components/
│       └── button.test.tsx
└── utils/
    └── validation.ts
```

---

## Stability & Reliability

### Stability Rules

1. **Defensive programming** - Null checks, optional chaining
2. **Error recovery** - Hata durumunda graceful recovery
3. **State persistence** - Critical state AsyncStorage'da persist et
4. **Offline support** - Network yokken cached data göster
5. **Memory management** - Unnecessary re-renders, memory leaks önle

### Memory Management

```typescript
// ✅ DOĞRU - Cleanup in useEffect
useEffect(() => {
  const subscription = listener.subscribe();
  return () => subscription.unsubscribe();
}, []);

// ✅ DOĞRU - AbortController for cancellable requests
useEffect(() => {
  const controller = new AbortController();
  fetchData(controller.signal);
  return () => controller.abort();
}, []);
```

---

## Logging & Debugging

### Logging Rules

1. **Structured logging** - Development'ta console.log, production'da service
2. **Log levels** - debug, info, warn, error
3. **No sensitive data** - Passwords, tokens loglama
4. **Error context** - Error loglarında context bilgisi

### Logging Pattern

```typescript
// utils/logger.ts
export const logger = {
  debug: (message: string, data?: unknown) => {
    if (__DEV__) {
      console.log(`[DEBUG] ${message}`, data);
    }
  },
  error: (message: string, error: Error, context?: Record<string, unknown>) => {
    console.error(`[ERROR] ${message}`, error, context);
    // Send to error reporting service in production
  },
};
```

---

## Data Validation & Sanitization

### Validation Rules

1. **Input validation** - Tüm user input validate et
2. **Type validation** - Runtime'da data type kontrolü
3. **Schema validation** - Complex objects için schema (Zod önerilir ama lightweight alternatif)
4. **Sanitization** - XSS ve injection attacks önle

### Validation Pattern

```typescript
// ✅ DOĞRU - Type-safe validation
interface MealPlanInput {
  weekStart: string;
  weekEnd: string;
}

function validateMealPlan(input: unknown): input is MealPlanInput {
  return (
    typeof input === "object" &&
    input !== null &&
    "weekStart" in input &&
    "weekEnd" in input &&
    typeof input.weekStart === "string" &&
    typeof input.weekEnd === "string"
  );
}
```
